using System.Collections;
using UnityEngine;

// Ensure GenerateMaterialForParam is present on the same GameObject
[RequireComponent(typeof(GenerateMaterialForParam))]
public class GenerateMeshForParam : MonoBehaviour
{
    public float meshScale = 1f;  // Scale factor for the size of the mesh

    private Mesh mesh;  // Mesh to be created
    private GenerateMaterialForParam materialGenerator;  // Reference to the other script

    private void Start()
    {
        // Get the GenerateMaterialForParam component from the same GameObject
        materialGenerator = GetComponent<GenerateMaterialForParam>();

        // Wait for the material to be generated by the other script before creating the mesh
        StartCoroutine(WaitForMaterialAndCreateMesh());
    }

    private IEnumerator WaitForMaterialAndCreateMesh()
    {
        // Wait until the material is available in the other script
        while (materialGenerator.targetMaterial == null || materialGenerator.targetMaterial.mainTexture == null)
        {
            yield return null;
        }

        // Create the mesh based on the texture size
        CreatePlaneMeshFromTexture(materialGenerator.targetMaterial.mainTexture);
    }

    private void CreatePlaneMeshFromTexture(Texture texture)
    {
        // Get texture dimensions (number of pixels)
        int width = texture.width;
        int height = texture.height;

        // Create a new GameObject with a MeshFilter and MeshRenderer
        GameObject meshObject = new GameObject("Generated Mesh");
        meshObject.transform.SetParent(this.transform);  // Attach to the same GameObject

        // Add components for mesh rendering
        MeshFilter meshFilter = meshObject.AddComponent<MeshFilter>();
        MeshRenderer meshRenderer = meshObject.AddComponent<MeshRenderer>();

        // Assign the material from the other script to the MeshRenderer
        meshRenderer.material = materialGenerator.targetMaterial;

        // Generate the mesh
        mesh = new Mesh();
        Vector3[] vertices = new Vector3[width * height];
        Vector2[] uv = new Vector2[width * height];
        int[] triangles = new int[(width - 1) * (height - 1) * 6];

        // Populate vertices, UVs, and triangles
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int index = y * width + x;
                vertices[index] = new Vector3(x * meshScale, 0, y * meshScale);  // Position each vertex
                uv[index] = new Vector2((float)x / (width - 1), (float)y / (height - 1));  // UV mapping
            }
        }

        // Generate triangles for the plane mesh
        int t = 0;
        for (int y = 0; y < height - 1; y++)
        {
            for (int x = 0; x < width - 1; x++)
            {
                int index = y * width + x;

                // First triangle
                triangles[t++] = index;
                triangles[t++] = index + width;
                triangles[t++] = index + width + 1;

                // Second triangle
                triangles[t++] = index;
                triangles[t++] = index + width + 1;
                triangles[t++] = index + 1;
            }
        }

        // Assign vertices, UVs, and triangles to the mesh
        mesh.vertices = vertices;
        mesh.uv = uv;
        mesh.triangles = triangles;
        mesh.RecalculateNormals();

        // Set the mesh to the MeshFilter
        meshFilter.mesh = mesh;

        Debug.Log("Mesh generated from texture with " + width + "x" + height + " vertices.");
    }
}
